<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TableHockey</title>
    <style>
            body{
                margin:0;
            }
            canvas{
                display:black;
            }

    </style>
</head>
<body>
    <script src="three.js"></script>
    <script scr=""    
    <script type="module" src="GLTFLoader.js"></script>
    <script src="DragControls.js"></script>
    <script src="OrbitControls.js"></script>
    <script type="module">
    
    import {GLTFLoader} from "./GLTFLoader.js"

    var scene = new THREE.Scene();
    var mouse = new THREE.Vector2();
    var raycaster = new THREE.Raycaster();
	let INTERSECTED;
     
    /*
var width = 10;
    var height = width * ( window.innerHight / window.innerWidth );
    var camera = new THREE.OrthographicCamera( width / - 2, width / 2, height / 2, height / - 2, 1, 100 );
    */
   var camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.01,
        1000);
    
    camera.position.set( 15, 30, 0 );
    camera.lookAt( 0, 0, 0 );

    var renderer = new THREE.WebGLRenderer(); 
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    document.body.appendChild(renderer.domElement);
    const controls = new THREE.MapControls( camera, renderer.domElement );
    var loader = new GLTFLoader();
    
    scene.background = new THREE.Color( '#E0F4C0' );
    
    var material_1 = new THREE.MeshLambertMaterial({
        color:'#00b3ff'
    });
    var material_2 = new THREE.MeshLambertMaterial({
        color:'#FBBE4D'
    });
    var field_material = new THREE.MeshLambertMaterial({
        color:'#ECF8FF'
    });

    scene.background = new THREE.Color('#EDFFC9');
    // var light = new THREE.HemisphereLight(0xfffff, 0x000000, 0.4 );
    // scene.add(light);
    // light.position.set(0,30,0)
    const rectLight = new THREE.DirectionalLight( 0xffffff, 1.2 );
    rectLight.position.set( -5, 10, -10 );
    rectLight.lookAt( 0, 0, 0 );
    rectLight.castShadow = true;
    rectLight.shadow.mapSize.width = 512; 
    rectLight.shadow.mapSize.height = 512; 
    rectLight.shadow.camera.near = 0.5;
    rectLight.shadow.camera.far = 500; 
    scene.add( rectLight )
    
    var field, player_1, player_2, puck, color_1, color_2;
    
    color_1 = new THREE.Color('#FFCD82');
    color_2 = new THREE.Color('#82E4FF');
   // var material = new MeshBasicMaterial({ color:0x0000 });
   // var player_2 = new THREE.Mesh(material);
    loader.load("./3D-Models/Field.glb", function(gltf){
        field = gltf.scene;
        scene.add(gltf.scene);
        field.castShadow = true;
    })
    loader.load("./3D-Models/Player_1.gltf", function(gltf){
        player_1 = gltf.scene;
        scene.add(gltf.scene);
        player_1.castShadow = true;
    })
    loader.load("./3D-Models/Player_2.gltf", function(gltf){
        player_2 = gltf.scene;
        scene.add(gltf.scene);
        player_2.castShadow = true;
    })
    loader.load("./3D-Models/Puck.gltf", function(gltf){
        puck = gltf.scene;
        scene.add(gltf.scene);
        puck.castShadow = true;
    })
    loader.load("./3D-Models/Puck.gltf", function(gltf){
        puck = gltf.scene;
        scene.add(gltf.scene);
        puck.castShadow = true;
    })
    
  //Example of how to make a Mesh Cylinder
  /*  var geometry = new THREE.CylinderGeometry( 2.1, 2.1, 3, 20);

    var material = new THREE.MeshLambertMaterial({
        color:0xF0032222

    });
    var mesh = new THREE.Mesh(geometry, material);
    scene.add(mesh);*/

    function animate() {
        requestAnimationFrame(animate);

        if (player_1 && player_2 && field) {
            //player_1.material.emissive.setHex( 0xff0000 );
        }
        
        highlight();
        window.addEventListener( 'resize', onWindowResize );
        renderer.render(scene, camera);
    }

    function onWindowResize() {

    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();

    renderer.setSize( window.innerWidth, window.innerHeight );
}

    function highlight() {
        raycaster.setFromCamera( mouse, camera );

            const intersects = raycaster.intersectObjects( scene.children, true );

            if ( intersects.length > 0 ) {

                if ( INTERSECTED != intersects[ 0 ].object ) {

                    if ( INTERSECTED ) INTERSECTED.material.emissive.setHex( INTERSECTED.currentHex );

                    INTERSECTED = intersects[ 0 ].object;
                    INTERSECTED.currentHex = INTERSECTED.material.emissive.getHex();
                    INTERSECTED.material.emissive.setHex( 0xff0000 );
                    document.addEventListener( 'mousedown', onDocumentMouseDown, false );

                }

            } else {

                if ( INTERSECTED ) INTERSECTED.material.emissive.setHex( INTERSECTED.currentHex );

                INTERSECTED = null;

            }

            renderer.render( scene, camera );
    }

    /*window.addEventListener('mousemove', function (event) {
        document.getElementById('mouse_x').textContent = event.x
        document.getElementById('mouse_y').textContent = event.y
    });*/

    function onMouseMove( event ) {
	// calculate mouse position in normalized device coordinates
	// (-1 to +1) for both components
	mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
	mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
    }

    window.addEventListener('mousemove', onMouseMove, false);

    animate();
    controls.update();
     
    </script>

</body>
</html>