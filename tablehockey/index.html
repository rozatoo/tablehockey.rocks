<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TableHockey</title>
    <style>
            body{
                margin:0;
            }
            canvas{
                display:black;
            }

    </style>
</head>
<body>

    <script src="three.js"></script>
    <script type="module" src="GLTFLoader.js"></script>
    <script src="DragControls.js"></script>
    <script src="OrbitControls.js"></script>
    <script type="module">
    
    import {GLTFLoader} from "./GLTFLoader.js"

    var scene = new THREE.Scene();
    var mouse = new THREE.Vector2();
    var raycaster = new THREE.Raycaster();
	let INTERSECTED;
     
    var camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.01,
        1000
    );
    var renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);
    const controls = new THREE.MapControls( camera, renderer.domElement );
    var loader = new GLTFLoader();
    
    scene.background = new THREE.Color( '#E0F4C0' );
    
    var material_1 = new THREE.MeshLambertMaterial({
        color:'#00b3ff'
    });
    var material_2 = new THREE.MeshLambertMaterial({
        color:'#FBBE4D'
    });
    var field_material = new THREE.MeshLambertMaterial({
        color:'#ECF8FF'
    });
    
    var light = new THREE.HemisphereLight( '#e7e7e7', '#b2b2b2', 1.1 );
    // var light = new THREE.PointLight(0xfffff, 2, 200);
    light.position.set(0, 30, 0)
    scene.add(light);

    camera.position.set(300, 300, 300);
    camera.lookAt(0, 0, 0);

    /*
    var field, player_1, player_2, puck;

    loader.load("./3D-Models/Field.gltf", function(gltf){
        field = gltf.scene;
        scene.add(gltf.scene);
    })
    loader.load("./3D-Models/Player_1.gltf", function(gltf){
        player_1 = gltf.scene;
        scene.add(gltf.scene);
    })
    loader.load("./3D-Models/Player_2.gltf", function(gltf){
        player_2 = gltf.scene;
        scene.add(gltf.scene);
    })
    loader.load("./3D-Models/Puck.gltf", function(gltf){
        puck = gltf.scene;
        scene.add(gltf.scene);
    })
    console.log("scene.chlidren after gltf loaded: " + scene.children)
    */

  //Example of how to make a Mesg Cylinder
    var player_geometry = new THREE.CylinderGeometry( 21, 21, 8, 20 );
    var field_geometry = new THREE.BoxGeometry( 450, 1, 300 );

    var player_1 = new THREE.Mesh(player_geometry, material_1);
    scene.add(player_1);
    var player_2 = new THREE.Mesh(player_geometry, material_2);
    scene.add(player_2);
    player_1.position.set(30, 0, 30);

    var field = new THREE.Mesh(field_geometry, field_material);
    field.position.set( 20, -5, 20 )
    if (field);
    scene.add(field);
    function animate() {
        requestAnimationFrame(animate);

        /*obj.rotation.x = 1;
        obj.rotation.y = 4.7;
        obj.rotation.z = 3;
        //light.position.x =+ 0.001;
        
        player_1.position.x = 0.01;
        player_2.position.y = 0.005;
        */ 
       if (player_1 && player_2) {
           // mesh.position.z += 0.05
       }
        highlight();
        renderer.render(scene, camera);
    }

    function highlight() {

        const intersects = raycaster.intersectObjects( scene.children );

				if ( intersects.length > 0 ) {

					const targetDistance = intersects[ 0 ].distance;

					if ( INTERSECTED != intersects[ 0 ].object ) {

						if ( INTERSECTED ) INTERSECTED.material.emissive.setHex( INTERSECTED.currentHex );

						INTERSECTED = intersects[ 0 ].object;
						INTERSECTED.currentHex = INTERSECTED.material.emissive.getHex();
						INTERSECTED.material.emissive.setHex( 0xff0000 );
                        console.log("a");
					}

				} else {

					if ( INTERSECTED ) INTERSECTED.material.emissive.setHex( INTERSECTED.currentHex );

					INTERSECTED = null;
				}
					scene.overrideMaterial = null;

					renderer.clear();
					renderer.render( scene, camera );
    }

    window.addEventListener('mousemove', function (event) {
        document.getElementById('mouse_x').textContent = event.x
        document.getElementById('mouse_y').textContent = event.y
    });

   /* function hoverPieces() {  
        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(scene.children);
        console.log("scene.children.size = " + scene.children.length);
        console.log("scene.children.<something> : " + scene.children);
            for (let i = 0; i < intersects.length; i++) {
                console.log("a");
                intersects[i].object.material.transparent = true;
                intersects[i].object.material.opacity = 0.5;
                document.getElementById('no').textContent = event.x
            }
    }*/

    function onWindowResize() {
        camera.aspect = window.innerwidth / window.innerhight;
        renderer.setSize(window.innerWidth, window.innerHight);
    }

    function onMouseMove( event ) {
	// calculate mouse position in normalized device coordinates
	// (-1 to +1) for both components
	mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
	mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
    }

    window.addEventListener('resize', onWindowResize);
    window.addEventListener('mousemove', onMouseMove, false);

    
    animate();
    controls.update();
    //hoverPieces();
     
    </script>

    <p>
        X : <span id="mouse_x"></span>
    </p>
    <p>
        Y : <span id="mouse_y"></span>
    </p>
    
</body>
</html>